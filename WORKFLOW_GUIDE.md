# Workflow Guide

How to write workflows in this repository.

---

## Workflow YAML Structure

Every workflow lives in `workflows/<category>/<name>/workflow.yaml`:

```yaml
name: my_workflow           # Unique identifier (no spaces)
display_name: My Workflow   # Human-readable name for UI
version: "1.0"
description: |
  What this workflow does.
  Supports **markdown**.

trigger:
  schema:
    # JSON Schema for input form
  ui_hints:
    layout: vertical
    submit_label: "Run"

nodes:
  - id: step_one
    type: function
    # ...
```

---

## Trigger Schema

Defines the input form auto-generated by the UI.

```yaml
trigger:
  schema:
    type: object
    required:
      - target_handle
    properties:
      target_handle:
        type: string
        title: "Publication Handle"
        description: "Help text shown in UI"
      count:
        type: integer
        default: 10
      mode:
        type: string
        enum: ["fast", "thorough"]
        default: "fast"
  ui_hints:
    layout: vertical
    submit_label: "Start"
```

**Supported types:** `string`, `integer`, `number`, `boolean`, `array`

---

## Node Types

### 1. Function Node

Calls a Python function.

```yaml
- id: process_items
  type: function
  description: What this step does
  config:
    path: "nodes.module.function_name"
    params:
      target_handle: "{{target_handle}}"
      items: "{{previous_output}}"
  routes:
    success: next_step
    no_items: __END__
    error: __ERROR__
```

**Path format:** `nodes.<module>.<function>` or `workflows.<workflow>.nodes.<module>.<function>`

### 2. Conditional Node

Routes based on expression.

```yaml
- id: check_mode
  type: conditional
  description: Branch based on mode
  config:
    expression: "{{published_url}} != null"
  routes:
    finalize: do_finalize
    prepare: do_prepare
```

**Expression result** determines route: `true`/`false` or custom values.

---

## State & Variable Access

Workflow state is a flat dict. Access with `{{variable}}`.

**Trigger inputs:**
```yaml
params:
  handle: "{{target_handle}}"   # From trigger schema
```

**Previous node outputs:**
```yaml
params:
  items: "{{items}}"            # Output from earlier node
  first: "{{items[0].title}}"   # Nested access
```

**Chained access:**
```yaml
params:
  content: "{{source_content}}"  # Set by load_context node
```

---

## Routing

### Special Routes

| Route | Meaning |
|-------|---------|
| `__END__` | End workflow successfully |
| `__ERROR__` | End workflow with error |

### Status Routing

Nodes return a `status` field. Routes map status to next node:

```yaml
routes:
  success: next_step
  no_pending_items: __END__
  error: __ERROR__
```

**Rule:** Any status without a matching route **fails the workflow** (fail loudly principle).

### Success Statuses (auto-complete)

These statuses with no route end normally: `success`, `completed`, `done`, `ok`, `skipped`, `no_new_items`

---

## Node Function Contract

```python
async def my_node(ctx, params: MyInput) -> MyOutput:
    """Node docstring."""

    # 1. Report inputs (for debugging)
    ctx.report_input({
        "target": params.target_handle,
        "count": len(params.items),
    })

    # 2. Do work
    results = await process(params.items)

    # 3. Report outputs
    ctx.report_output({
        "processed": len(results),
        "status": "success",
    })

    # 4. Return Pydantic model
    return MyOutput(
        items=results,
        count=len(results),
        status="success",
    )
```

**Rules:**
- Use Pydantic schemas for Input/Output (see `CONVENTIONS.md`)
- Always call `ctx.report_input()` and `ctx.report_output()`
- Return explicit `status` field for routing
- See `nodes/schemas.py` for schema definitions

---

## Error Recovery Pattern

For workflows that lock resources, implement recovery:

```yaml
- id: do_work
  type: function
  config:
    path: "nodes.worker.process"
  routes:
    success: __END__
    error: rollback_and_fail   # Don't go to __ERROR__ directly

- id: rollback_and_fail
  type: function
  config:
    path: "nodes.worker.rollback"
  routes:
    success: __ERROR__         # Still fail, but after cleanup
    error: __ERROR__
```

---

## Registration

**Add new workflows to `manifest.yaml`:**

```yaml
workflows:
  - path: "workflows/substack/my_workflow"
    enabled: true
    description: "What it does"
```

Restart backend after changes.

---

## Checklist for New Workflows

- [ ] Created `workflows/<category>/<name>/workflow.yaml`
- [ ] Defined trigger schema with required fields
- [ ] All nodes have `description` field
- [ ] All routes handle `error` case
- [ ] Custom statuses have matching routes
- [ ] Node functions use Pydantic schemas
- [ ] Added to `manifest.yaml`
- [ ] Created Deployment via UI (see `CONVENTIONS.md`)
- [ ] Created vault config with input defaults via UI (if needed)
